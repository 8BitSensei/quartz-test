2023-04-25
#CompSci 

> The literature offers two main approaches on the topic. A first one understands computational systems as defined by distinct ontologies for software and hardware, usually taken to be their elementary components. A different approach sees computational systems as comprising several other elements around the software-hardware dichotomy: under this second view, computational systems are defined on the basis of a hierarchy of levels of abstraction, arranging hardware levels at the bottom of such a hierarchy and extending upwards to elements of the design and downwards to include the user. [^1]


#### Software & Hardware

Computational Systems are usually understood to be composed of two distinct ontological entities, software and hardware, or abstract and concrete entities.

Abstract entities:
- Algorithms
- Source Code
- Programs

Concrete entities:
- Microprocessors
- Hard drives
- Computing Machines

>Moore (1978) argues that such a duality is one of the three myths of computer science, in that the dichotomy software/hardware has a pragmatic, but not an ontological, significance [^2]

> Software is defined as any pattern that is amenable to being read and executed: once one realizes that all physical objects display patterns, one is forced to accept the conclusion that hardware, as a physical object, is also software. [^2]

Colburn keeps software and hardware apart, stressing that software has both an abstract and a concrete nature, it has a "medium of description" (the language it is expressed in) and a "medium of execution" (the hardware it runs on). He points out that while software is always concrete in some physical medium, it is abstract because programmers do not what to consider the implementing machines when developing a program, that would rather it be executable by any computer. To me, this seems odd, yes, I would like my software to be universally executable, but it is not! and I often have to deal with that on a day to day basis.

Irmak considers software to only cease existing when all copies of it are destroyed *and there is no longer memory of it*, suggesting that software is something broader than just a language implementation, perhaps that it is a non-corporeal pattern.




---
# References

[^1]: https://plato.stanford.edu/entries/computer-science/#CompSyst
[^2]: https://plato.stanford.edu/entries/computer-science/#SoftHard